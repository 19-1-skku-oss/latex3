% \iffalse meta-comment
%
%% File: l3fp-random.dtx Copyright (C) 2016-2018 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
% This file is part of the "l3kernel bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/latex3
%
% for those people who are interested.
%
%<*driver>
\documentclass[full,kernel]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{l3fp-random} package\\
%   Floating point random numbers}
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
% \date{Released 2018-04-30}
%
% \maketitle
%
% \begin{documentation}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3fp-random} Implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=fp>
%    \end{macrocode}
%
% \begin{macro}[EXP]{\@@_parse_word_rand:N , \@@_parse_word_randint:N}
%   Those functions may receive a variable number of arguments.  We
%   won't use the argument~|?|.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_word_rand:N
  { \@@_parse_function:NNN \@@_rand_o:Nw ? }
\cs_new:Npn \@@_parse_word_randint:N
  { \@@_parse_function:NNN \@@_randint_o:Nw ? }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Engine support}
%
% Most engines provide random numbers, but not all.  We write the test
% twice simply in order to write the \texttt{false} branch first.
%    \begin{macrocode}
\sys_if_rand_exist:F
  {
    \__kernel_msg_new:nnn { kernel } { fp-no-random }
      { Random~numbers~unavailable~for~#1 }
    \cs_new:Npn \@@_rand_o:Nw ? #1 @
      {
        \__kernel_msg_expandable_error:nnn { kernel } { fp-no-random }
          { fp~rand }
        \exp_after:wN \c_nan_fp
      }
    \cs_new_eq:NN \@@_randint_o:Nw \@@_rand_o:Nw
    \cs_new:Npn \int_rand:nn #1#2
      {
        \__kernel_msg_expandable_error:nnn { kernel } { fp-no-random }
          { \int_rand:nn {#1} {#2} }
        \int_eval:n {#1}
      }
  }
\sys_if_rand_exist:T
  {
%    \end{macrocode}
%
% Obviously, every word \enquote{random} below means
% \enquote{pseudo-random}, as we have no access to entropy (except a
% very unreliable source of entropy: the time it takes to run some
% code).
%
% The primitive random number generator (RNG) is provided as
% \cs{tex_uniformdeviate:D}.  Under the hood, it maintains an array of
% $55$ $28$-bit numbers, updated with a linear recursion relation
% (similar to Fibonacci numbers) modulo $2^{28}$.  When
% \cs{tex_uniformdeviate:D} \meta{integer} is called (for brevity denote
% by~$N$ the \meta{integer}), the next $28$-bit number is read from the
% array, scaled by $N/2^{28}$, and rounded.  To prevent $0$ and $N$ from
% appearing half as often as other numbers, they are both mapped to the
% result~$0$.
%
% This process means that \cs{tex_uniformdeviate:D} only gives a uniform
% distribution from $0$ to $N-1$ if $N$ is a divisor of $2^{28}$, so we
% will mostly call the RNG with such power of~$2$ arguments.  If $N$
% does not divide $2^{28}$, then the relative non-uniformity (difference
% between probabilities of getting different numbers) is about
% $N/2^{28}$ and could be detected after generating roughly $2^{56}/N^2$
% random numbers.  For instance for $N=98304=3\times 2^{15}$, the bias
% modulo~$3$ would be detectable after roughly $2^{23}$ calls to the RNG
% (experimentally this takes roughly a second on a 1 giga-hertz
% processor).  While this bias is not quite problematic, it is
% uncomfortably close to being so, and it becomes worse as $N$ is
% increased.  In our code, we shall thus combine several results from
% the RNG\@.
%
% The RNG has two types of unexpected correlations.  First, everything
% is linear modulo~$2^{28}$, hence the lowest $k$ bits of the random
% numbers only depend on the lowest $k$ bits of the seed (and of course
% the number of times the RNG was called since setting the seed).  The
% recommended way to get a number from $0$ to $N-1$ is thus to scale the
% raw $28$-bit integer, as the engine's RNG does.  We will go further
% and in fact typically we discard some of the lowest bits.
%
% Second, suppose that we call the RNG with the same argument~$N$ to get
% a set of $K$ integers in $[0,N-1]$ (throwing away repeats), and
% suppose that $N>K^3$ and $K>55$.  The recursion used to construct more
% $28$-bit numbers from previous ones is linear:
% $x_n = x_{n-55} - x_{n-24}$ or $x_n = x_{n-55}-x_{n-24}+2^{28}$.
% After rescaling and rounding we find that the result $N_n\in[0,N-1]$
% is among $N_{n-55} - N_{n-24} + \{-1,0,1\}$ modulo~$N$ (a more
% detailed analysis shows that $0$ appears with frequency close
% to~$3/4$).  The resulting set thus has more triplets $(a,b,c)$ than
% expected obeying $a=b+c$ modulo~$N$.  Namely it will have of order
% $(K-55)\times 3/4$ such triplets, when one would expect $K^3/(6N)$.
% This starts to be detectable around $N=2^{18}>55^3$ (earlier if one
% keeps track of positions too, but this is more subtle than it looks
% because the array of $28$-bit integers is read backwards by the
% engine).  Hopefully the correlation is subtle enough to not affect
% realistic documents so we do not specifically mitigate against this.
% Since we typically use two calls to the RNG per \cs{int_rand:nn} we
% would need to investigate linear relations between the $x_{2n}$ on the
% one hand and between the $x_{2n+1}$ on the other hand.  Such relations
% will have more complicated coefficients than $\pm 1$, which alleviates
% the issue.
%
% Ideally, our algorithm should be:
% \begin{itemize}
% \item Uniform.  The result should be as uniform as possible assuming
%   that the RNG's underlying $28$-bit integers are uniform.
% \item Uncorrelated.  The result should not have detectable
%   correlations between different seeds, similar to the lowest-bit ones
%   mentioned earlier.
% \item Quick.  The algorithm should be fast in \TeX{}, so no
%   \enquote{bit twiddling}, but \enquote{digit twiddling} is ok.
% \item Simple.  The behaviour must be documentable precisely.
% \item Predictable.  The number of calls to the RNG should be the same
%   for any \cs{int_rand:nn}, because then the algorithm can be modified
%   later without changing the result of other uses of the RNG\@.
% \item Robust.  It should work even for \cs{int_rand:nn} |{| |-|
%   \cs{c_max_int} |}| |{| \cs{c_max_int} |}| where the range is not
%   representable as an integer.  In fact, we also provide later a
%   floating-point |randint| whose range can go all the way up to
%   $2\times 10^{16}-1$ possible values.
% \end{itemize}
% Some of these requirements conflict.  For instance, uniformity cannot
% be achieved with a fixed number of calls to the RNG\@.
%
% Denote by $\operatorname{random}(N)$ one call to
% \cs{tex_uniformdeviate:D} with argument~$N$, and by
% $\operatorname{ediv}(p,q)$ the \eTeX{} rounding division giving
% $\lfloor p/q+1/2\rfloor$.  Denote by $\meta{min}$, $\meta{max}$ and
% $R=\meta{max}-\meta{min}+1$ the arguments of \cs{int_min:nn} and the
% number of possible outcomes.  Note that $R\in [0,2^{32}-1]$ cannot
% necessarily be represented as an integer.  Our strategy is to get two
% $28$-bit integers $X$ and $Y$ from the RNG, split each into $14$-bit
% integers, as $X=X_1\times 2^{14}+X_0$ and $Y=Y_1\times 2^{14}+Y_0$
% then return essentially
% $\meta{min} + \lfloor R (X_1\times 2^{-14} + Y_1\times 2^{-28} +
% Y_0\times 2^{-42} + X_0\times 2^{-56})\rfloor$.  For small~$R$ the
% $X_0$ term has a tiny effect so we ignore it and we can compute
% $R\times Y/2^{28}$ much more directly by $\operatorname{random}(R)$.
% \begin{itemize}
% \item If $R \leq 2^{17}$ then return
%   $\meta{min} + \operatorname{ediv}(R\operatorname{random}(2^{14}) +
%   \operatorname{random}(R) - 2^{13}, 2^{14})$.  The shift by $2^{13}$
%   converts \eTeX{} division to truncated division.  The bound on $R$
%   ensures that the number obtained before the shift and division is at
%   most $2^{17}(2^{14}-1)+(2^{17}-1)=\cs{c_max_int}$.  The
%   non-uniformity is at most of order $2^{17}/2^{42} = 2^{-25}$.
% \item Otherwise, split $R=R_2\times 2^{28}+R_1\times 2^{14}+R_0$,
%   precompute $R_{21}=R_2\times 2^{14}+R_1$ and
%   $R_{10}=R_1\times 2^{14}+R_0$ and $Z = X_1\times 2^{14}+Y_1$.  Then
%   compute on the one hand
%   $\meta{min}+8\times Z+(R_2-8)\times Z+R_1\times X_1$ (where the
%   weird split of $R_2\times Z$ avoids a possible overflow) and
%   $\operatorname{ediv}(R_2\times Y_0 + R_0\times X_1 +
%   \operatorname{ediv}(R_{21}\times X_0,2^{28}) +
%   \operatorname{ediv}(R_{10}\times Y,2^{28}),2^{14})$ then sum them
%   (this may give $2^{31}$, an overflow).  If the result is greater
%   than $\meta{max}$ (in particular if it overflows) then replace it by
%   $\meta{min}$.
% \item To get a floating point number in $[0,1)$ just call the
%   $R=10000\leq 2^{17}$ procedure above to produce four blocks of four
%   digits.
% \item To get an integer floating point number in a small range
%   $R\leq 2^{17}$ use the above simplified algorithm.  If the range is
%   bigger (it can be up to $2\times 10^{16}-1$), work with fixed-point
%   numbers: get six times four digits to build a fixed point number,
%   multiply by $R$ and add $\meta{min}$.
% \end{itemize}
% This is strategy is not yet implemented at all.
%
% \begin{macro}[EXP]{\@@_rand_uniform:}
% \begin{variable}
%   {
%     \c_@@_rand_size_int,
%     \c_@@_rand_four_int,
%     \c_@@_rand_eight_int,
%   }
%   The \cs{tex_uniformdeviate:D} primitive gives a pseudo-random
%   integer in a range $[0,n-1]$ of the user's choice.  This number is
%   meant to be uniformly distributed, but is produced by rescaling a
%   uniform pseudo-random integer in $[0,2^{28}-1]$.  For instance,
%   setting~$n$ to (any multiple of) $2^{29}$ gives only even values.
%   Thus it is only safe to call \cs{tex_uniformdeviate:D} with
%   argument $2^{28}$.  This integer is also used in the implementation
%   of \cs{int_rand:nn}.  We also use variants of this number
%   rounded down to multiples of $10^4$ and $10^8$.
%    \begin{macrocode}
    \cs_new:Npn \@@_rand_uniform:
      { \tex_uniformdeviate:D \c_@@_rand_size_int }
    \int_const:Nn \c_@@_rand_size_int   { 268 435 456 }
    \int_const:Nn \c_@@_rand_four_int   { 268 430 000 }
    \int_const:Nn \c_@@_rand_eight_int  { 200 000 000 }
%    \end{macrocode}
% \end{variable}
% \end{macro}
%
% \begin{macro}[EXP]{\@@_rand_myriads:n}
% \begin{macro}[EXP]
%   {
%     \@@_rand_myriads_loop:nn,
%     \@@_rand_myriads_get:w,
%     \@@_rand_myriads_last:,
%     \@@_rand_myriads_last:w,
%   }
%   Used as \cs{@@_rand_myriads:n} |{XXX}| with one input character per
%   block of four digit we want.  Given a pseudo-random integer from the
%   primitive, we extract $2$ blocks of digits if possible, namely if
%   the integer is less than $2\times 10^8$.  If that's not possible,
%   we try to extract $1$~block, which succeeds in the range $[2\times
%   10^8, 26843\times 10^4)$.  For the $5456$ remaining possible values
%   we just throw away the random integer and get a new one.  Depending
%   on whether we got $2$, $1$, or~$0$ blocks, remove the same number of
%   characters from the input stream with \cs{use_i:nnn}, \cs{use_i:nn}
%   or nothing.
%    \begin{macrocode}
    \cs_new:Npn \@@_rand_myriads:n #1
      {
        \@@_rand_myriads_loop:nn #1
          { ? \use_i_delimit_by_q_stop:nw \@@_rand_myriads_last: }
          { ? \use_none_delimit_by_q_stop:w } \q_stop
      }
    \cs_new:Npn \@@_rand_myriads_loop:nn #1#2
      {
        \use_none:n #2
        \exp_after:wN \@@_rand_myriads_get:w
        \int_value:w \@@_rand_uniform: ; {#1}{#2}
      }
    \cs_new:Npn \@@_rand_myriads_get:w #1 ;
      {
        \if_int_compare:w #1 < \c_@@_rand_eight_int
          \exp_after:wN \use_none:n
          \int_value:w \@@_int_eval:w
            \c_@@_rand_eight_int + #1 \@@_int_eval_end:
          \exp_after:wN \use_i:nnn
        \else:
          \if_int_compare:w #1 < \c_@@_rand_four_int
            \exp_after:wN \use_none:nnnnn
            \int_value:w \@@_int_eval:w
              \c_@@_rand_four_int + #1 \@@_int_eval_end:
            \exp_after:wN \exp_after:wN \exp_after:wN \use_i:nn
          \fi:
        \fi:
        \@@_rand_myriads_loop:nn
      }
    \cs_new:Npn \@@_rand_myriads_last:
      {
        \exp_after:wN \@@_rand_myriads_last:w
        \int_value:w \@@_rand_uniform: ;
      }
    \cs_new:Npn \@@_rand_myriads_last:w #1 ;
      {
        \if_int_compare:w #1 < \c_@@_rand_four_int
          \exp_after:wN \use_none:nnnnn
          \int_value:w \@@_int_eval:w
            \c_@@_rand_four_int + #1 \@@_int_eval_end:
        \else:
          \exp_after:wN \@@_rand_myriads_last:
        \fi:
      }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Random floating point}
%
% \begin{macro}[EXP]{\@@_rand_o:Nw}
% \begin{macro}[EXP]{\@@_rand_o:, \@@_rand_o:w}
%   First we check that |random| was called without argument.  Then get
%   four blocks of four digits.
%    \begin{macrocode}
    \cs_new:Npn \@@_rand_o:Nw ? #1 @
      {
        \tl_if_empty:nTF {#1}
          { \@@_rand_o: }
          {
            \__kernel_msg_expandable_error:nnnnn
              { kernel } { fp-num-args } { rand() } { 0 } { 0 }
            \exp_after:wN \c_nan_fp
          }
      }
    \cs_new:Npn \@@_rand_o:
      { \@@_parse_o:n { . \@@_rand_myriads:n { xxxx } } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Random integer}
%
% \begin{macro}[EXP]{\@@_randint_o:Nw}
% \begin{macro}[EXP]
%   {
%     \@@_randint_default:w,
%     \@@_randint_badarg:w,
%     \@@_randint_o:w,
%     \@@_randint_e:wnn,
%     \@@_randint_e:wwNnn,
%     \@@_randint_e:wwwNnn,
%     \@@_randint_narrow_e:nnnn,
%     \@@_randint_wide_e:nnnn,
%     \@@_randint_wide_e:wnnn,
%   }
%     Enforce that there is one argument (then add first argument~$1$)
%     or two arguments.  Enforce that they are integers in
%     $(-10^{16},10^{16})$ and ordered.  We distinguish narrow ranges
%     (less than $2^{28}$) from wider ones.
%
%     For narrow ranges, compute the number~$n$ of possible outputs as
%     an integer using \cs{fp_to_int:n}, and reduce a pseudo-random
%     $28$-bit integer~$r$ modulo~$n$.  On its own, this is not uniform
%     when $[0,2^{28}-1]$ does not divide evenly into intervals of
%     size~$n$.  The auxiliary \cs{@@_randint_e:wwwNnn} discards the
%     pseudo-random integer if it lies in an incomplete interval, and
%     repeats.
%
%     For wide ranges we use the same code except for the last eight
%     digits which use \cs{@@_rand_myriads:n}.  It is not safe to
%     combine the first digits with the last eight as a single string of
%     digits, as this may exceed $16$~digits and be rounded.  Instead,
%     we first add the first few digits (times $10^8$) to the lower
%     bound.  The result is compared to the upper bound and the process
%     repeats if needed.
%    \begin{macrocode}
    \cs_new:Npn \@@_randint_o:Nw ?
      {
        \@@_parse_function_one_two:nnw
          { randint }
          { \@@_randint_default:w \@@_randint_o:w }
      }
    \cs_new:Npn \@@_randint_default:w #1 { \exp_after:wN #1 \c_one_fp }
    \cs_new:Npn \@@_randint_badarg:w \s_@@ \@@_chk:w #1#2#3;
      {
        \@@_int:wTF \s_@@ \@@_chk:w #1#2#3;
          {
            \if_meaning:w 1 #1
              \if_int_compare:w
                \use_i_delimit_by_q_stop:nw #3 \q_stop > \c_@@_prec_int
                1 \exp_stop_f:
              \fi:
            \fi:
          }
          { 1 \exp_stop_f: }
      }
    \cs_new:Npn \@@_randint_o:w #1; #2; @
      {
        \if_case:w
            \@@_randint_badarg:w #1;
            \@@_randint_badarg:w #2;
            \fp_compare:nNnTF { #1; } > { #2; } { 1 } { 0 } \exp_stop_f:
          \exp_after:wN \exp_after:wN \exp_after:wN \@@_randint_e:wnn
            \@@_parse:n { #2; - #1; } { #1; } { #2; }
        \or:
          \@@_invalid_operation_tl_o:ff
            { randint } { \@@_array_to_clist:n { #1; #2; } }
          \exp:w
        \fi:
        \exp_after:wN \exp_end:
      }
    \cs_new:Npn \@@_randint_e:wnn #1;
      {
        \exp_after:wN \@@_randint_e:wwNnn
        \int_value:w \@@_rand_uniform: \exp_after:wN ;
        \exp:w \exp_end_continue_f:w
          \fp_compare:nNnTF { #1 ; } < \c_@@_rand_size_int
            { \fp_to_int:n { #1 ; + 1 } ; \@@_randint_narrow_e:nnnn }
            {
              \fp_to_int:n { floor(#1 ; * 1e-8 + 1) } ;
              \@@_randint_wide_e:nnnn
            }
      }
    \cs_new:Npn \@@_randint_e:wwNnn #1 ; #2 ;
      {
        \exp_after:wN \@@_randint_e:wwwNnn
        \int_value:w \int_mod:nn {#1} {#2} ; #1 ; #2 ;
      }
    \cs_new:Npn \@@_randint_e:wwwNnn #1 ; #2 ; #3 ; #4
      {
        \int_compare:nNnTF { #2 - #1 + #3 } > \c_@@_rand_size_int
          {
            \exp_after:wN \@@_randint_e:wwNnn
              \int_value:w \@@_rand_uniform: ; #3 ; #4
          }
          { #4 {#1} {#3} }
      }
    \cs_new:Npn \@@_randint_narrow_e:nnnn #1#2#3#4
      { \@@_parse_o:n { #3 + #1 } \exp:w }
    \cs_new:Npn \@@_randint_wide_e:nnnn #1#2#3#4
      {
        \exp_after:wN \exp_after:wN
        \exp_after:wN \@@_randint_wide_e:wnnn
          \@@_parse:n { #3 + #1e8 + \@@_rand_myriads:n { xx } }
          {#2} {#3} {#4}
      }
    \cs_new:Npn \@@_randint_wide_e:wnnn #1 ; #2#3#4
      {
        \fp_compare:nNnTF { #1 ; } > {#4}
          {
            \exp_after:wN \@@_randint_e:wwNnn
              \int_value:w \@@_rand_uniform: ; #2 ;
              \@@_randint_wide_e:nnnn {#3} {#4}
          }
          { \@@_exp_after_o:w #1 ; \exp:w }
      }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\int_rand:nn}
% \begin{macro}{\@@_randint:ww}
% \begin{macro}{\@@_randint_narrow:n}
% \begin{macro}{\@@_randint_narrow:nn}
% \begin{macro}{\@@_randint_narrow:nnn}
%   Evaluate the argument and filter out the case where the lower
%   bound~|#1| is more than the upper bound~|#2|.  Then determine
%   whether the range is narrower than \cs{c_@@_rand_size_int}; |#2-#1|
%   may overflow for very large positive~|#2| and negative~|#1|.  If the
%   range is wide, use slower code from \pkg{l3fp}.  If the range is
%   narrow, call \cs{@@_randint_narrow:n} \Arg{choices} where
%   \meta{choices} is the number of possible outcomes.
%
%   One option then would be to reduce a random number modulo
%   \meta{choices}, but the low-order bits of random numbers provided by
%   the primitive have poor randomness: empirical tests indicate that
%   taking random numbers modulo~$2$ gives only two possible sequences
%   of bits depending on the seed's parity.  Instead, fit in the output
%   range $[0,\cs{c_@@_rand_size_int}-1]$ of the random number generator
%   \meta{choices} equal-size intervals of maximum possible size
%   (obtained using \cs{int_div_truncate:nn}).  Given a random number,
%   divide it by the size to determine which interval it falls into; if
%   it is beyond \meta{choices}, try another random number.
%    \begin{macrocode}
    \cs_new:Npn \int_rand:nn #1#2
      {
        \exp_after:wN \@@_randint:ww
        \int_value:w \int_eval:n {#1} \exp_after:wN ;
        \int_value:w \int_eval:n {#2} ;
      }
    \cs_new:Npn \@@_randint:ww #1; #2;
      {
        \int_compare:nNnTF {#1} > {#2}
          {
            \__kernel_msg_expandable_error:nnnn
              { kernel } { randint-backward-range } {#1} {#2}
            \@@_randint:ww #2; #1;
          }
          {
            \int_compare:nNnTF {#1} > 0
              { \int_compare:nNnTF { #2 - #1 } < \c_@@_rand_size_int }
              { \int_compare:nNnTF {#2} < { #1 + \c_@@_rand_size_int } }
                  {
                    \int_eval:n
                      {
                        #1 +
                        \exp_args:Nf \@@_randint_narrow:n
                          { \int_eval:n { #2 - #1 + 1 } }
                      }
                  }
                  { \fp_to_int:n { randint(#1,#2) } }
          }
      }
    \cs_new:Npn \@@_randint_narrow:n #1
      {
        \exp_args:Nf \@@_randint_narrow:nn
          { \int_div_truncate:nn \c_@@_rand_size_int {#1} } {#1}
      }
    \cs_new:Npn \@@_randint_narrow:nn #1
      {
        \exp_args:Nf \@@_randint_narrow:nnn
          {
            \int_div_truncate:nn
              { \tex_uniformdeviate:D \c_@@_rand_size_int } {#1}
          }
          {#1}
      }
    \cs_new:Npn \@@_randint_narrow:nnn #1#2#3
      {
        \int_compare:nNnTF {#1} < {#3}
          {#1}
          { \@@_randint_narrow:nn {#2} {#3} }
      }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% End the initial conditional that ensures these commands are only
% defined in engines that support random numbers.
%    \begin{macrocode}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintChanges
%
% \PrintIndex
