% \iffalse
%
%% File l3benchmark.dtx Copyright (C) 2011,2012,2014-2018 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{expl3}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3benchmark} package\\ Benchmark^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released 2018-04-30}
%
% \maketitle
%
% \begin{documentation}
%
% \section{Benchmark}
%
% \begin{function}{\sys_timer_apply:N}
%   \begin{syntax}
%     \cs{sys_timer_apply:N} \meta{function}
%   \end{syntax}
%   Calls \meta{function} \Arg{time} where \meta{time} is the time
%   elapsed since the last \cs{sys_timer_gzero:}, which is also called
%   while loading the package.  The \meta{time} is an integer, measured
%   in scaled seconds, namely $2^{-16}$ seconds.  The integer may
%   overflow after about $9$ hours in some engines.
% \end{function}
%
% \begin{function}{\sys_timer_gzero:}
%   \begin{syntax}
%     \cs{sys_timer_gzero:}
%   \end{syntax}
%   Resets the timer to zero.
% \end{function}
%
% \begin{function}{\benchmark:n}
%   \begin{syntax}
%     \cs{benchmark:n} \Arg{code}
%   \end{syntax}
%   Measures the time taken by \TeX{} to run the \meta{code}, and calls
%   \cs{benchmark_display:n} with the time in seconds as its argument.
%   By default, that display function prints the time to the terminal.
%   The behaviour can be changed by redefining \cs{benchmark_display:n}.
%   This function cannot be nested.  The \meta{code} is run many times
%   in a row, and not within a group, thus it should not have
%   side-effects.
% \end{function}
%
% \begin{variable}{\l_benchmark_duration_int}
%   This variable controls the duration of the benchmark in scaled
%   seconds. Namely, the benchmark will take a time roughly between half
%   and twice \cs{l_benchmark_duration_int} scaled seconds.
% \end{variable}
%
% \begin{function}{\benchmark_tic:,\benchmark_toc:}
%   \begin{syntax}
%     |\benchmark_tic:| \meta{slow code} |\benchmark_toc:|
%   \end{syntax}
%   When it is not possible to run \cs{benchmark:n} (e.g., the code
%   is part of the execution of a package which cannot be looped)
%   the tic/toc commands can be used instead to time between two points
%   in the code.
%   When executed, |\benchmark_tic:| will print a line to the terminal,
%   and |\benchmark_toc:| will print a matching line with a time to indicate
%   the duration between them in seconds.
%   Note that these commands can be nested.
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3benchmark} implementation}
%
% Our working unit is the scaled second, namely $2^{-16}$ seconds.
%
% There are four cases: the elapsed time is available as the primitive
% \tn{pdfelapsedtime}, or through Heiko Oberdiek's \pkg{pdftexcmds} as
% \tn{pdf@elapsedtime}, or by accessing system time through
% \texttt{texlua} using unrestricted shell escape, or the elapsed time
% is not available.  The first two cases behave in the same way, while
% the third requires using floating point numbers.  The third way uses
% the following Lua code to print a large floating point number: the
% system time in scaled seconds; it is around $10^{14}$.
%    \begin{macrocode}
%<*lua>
if os.gettimeofday then
  io.write(65536 * os.gettimeofday())
else
  io.write(65536 * os.date("%s"))
end
%</lua>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage{l3benchmark}{2018-04-30}{}
  {L3 Experimental benchmarking}
%</package>
%    \end{macrocode}
%
% \subsection{Additions to \pkg{l3sys}: elapsed time}
%
%    \begin{macrocode}
%<@@=sys>
%    \end{macrocode}
%
% \begin{macro}{\@@_timer:}
% \begin{macro}[pTF]{\sys_if_timer_exist:}
%   In \LuaTeX{}, load Heiko's \pkg{pdftexcmds} to get
%   \tn{pdf@elapsedtime}, otherwise try to locate the primitive.  The
%   elapsed time will be available if this succeeds or if unrestricted
%   shell escape is available.
%    \begin{macrocode}
\sys_if_engine_luatex:TF
  {
    \RequirePackage{pdftexcmds} \scan_stop:
    \cs_new_eq:NN \@@_timer: \pdf@elapsedtime
  }
  {
    \cs_if_exist:NTF \tex_elapsedtime:D
      { \cs_new_eq:NN \@@_timer: \tex_elapsedtime:D }
      {
        \cs_if_exist:NT \pdfelapsedtime
          { \cs_new_eq:NN \@@_timer: \pdfelapsedtime }
      }
  }
\@@_const:nn { sys_if_timer_exist }
  { \cs_if_exist_p:N \@@_timer: || \sys_if_shell_unrestricted_p: }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\sys_timer_gzero:, \sys_timer_apply:N, \@@_timer:, \@@_timer_fp:}
% \begin{variable}{\g_@@_timer_base_int, \g_@@_timer_base_fp}
%   Three case, and in each case we define \cs{sys_timer_gzero:} then
%   \cs{sys_timer_apply:N}.  If \cs{@@_timer:} exists then it is safe to
%   use the corresponding \enquote{resettimer} code for
%   \cs{sys_timer_gzero:}, or as a fall-back use
%   \cs{g_@@_timer_base_int} as an offset.
%    \begin{macrocode}
\cs_if_exist:NTF \@@_timer:
  {
    \cs_if_exist:NTF \pdf@resettimer
      { \cs_new_eq:NN \sys_timer_gzero: \pdf@resettimer }
      {
        \cs_if_exist:NTF \tex_resettimer:D
          { \cs_new_eq:NN \sys_timer_gzero: \tex_resettimer:D }
          {
            \cs_if_exist:NTF \pdfresettimer
              { \cs_new_eq:NN \sys_timer_gzero: \pdfresettimer }
              {
                \int_new:N \g_@@_timer_base_int
                \cs_new_protected:Npn \sys_timer_gzero:
                  { \int_gset:Nn \g_@@_timer_base_int { \@@_timer: } }
              }
          }
      }
    \int_if_exist:NTF \g_@@_timer_base_int
      {
        \cs_new_protected:Npn \sys_timer_apply:N #1
          {
            \exp_args:Nf #1
              { \int_eval:n { \@@_timer: - \g_@@_timer_base_int } }
          }
      }
      {
        \cs_new_protected:Npn \sys_timer_apply:N #1
          { \exp_args:No #1 { \int_value:w \@@_timer: } }
      }
  }
%    \end{macrocode}
%   Otherwise we use unrestricted shell escape to define
%   \cs{@@_timer_fp:} (an analogue of \cs{@@_timer:} that produces a
%   floating point number), and we store the offset in
%   \cs{g_@@_timer_base_fp}.  We neutralize the end of file marker using
%   \cs{exp_not:N}.
%    \begin{macrocode}
  {
    \sys_if_shell_unrestricted:TF
      {
        \cs_new_protected:Npn \@@_timer_fp:
          {
            \int_eval:n
              { \tex_input:D " | texlua ~ l3sys-time.lua " ~ }
            \exp_stop_f:
          }
        \fp_new:N \g_@@_timer_base_fp
        \cs_new_protected:Npn \sys_timer_gzero:
          { \fp_gset:Nn \g_@@_timer_base_fp { \@@_timer_fp: } }
        \cs_new_protected:Npn \sys_timer_apply:N #1
          {
            \group_begin:
            \tex_everyeof:D { \exp_not:N }
            \exp_args:NNf \group_end:
              #1
              { \fp_to_int:n { \@@_timer_fp: - \g_@@_timer_base_fp } }
          }
      }
%    \end{macrocode}
%   Finally if the elapsed time cannot be accessed then we define user
%   commands to produce errors.
%    \begin{macrocode}
      {
        \__kernel_msg_new:nnnn { kernel } { no-elapsed-time }
          { No~clock~detected~for~#1. }
          {
            The~current~engine~provides~no~way~to~access~the~system~time,~
            hence~no~way~to~know~the~time~elapsed~without~shell-escape.~
            Please~use~pdfTeX,~LuaTeX,~or~call~other~engines~with~the~
            --shell-escape~option.
          }
        \cs_new_protected:Npn \sys_timer_gzero:
          {
            \__kernel_msg_error:nnn { kernel } { no-elapsed-time }
              { \sys_timer_gzero: }
          }
        \cs_new_protected:Npn \sys_timer_apply:N #1
          {
            \__kernel_msg_error:nnn { kernel } { no-elapsed-time }
              { \sys_timer_apply:N #1 }
          }
      }
  }
%    \end{macrocode}
% \end{variable}
% \end{macro}
%
% The following line is needed in engines where elapsed time comes from
% system time, because the starting value of the clock is otherwise very
% large (time is counted from epoch).  For consistency, we call
% \cs{sys_timer_gzero:} in all engines.
%    \begin{macrocode}
\sys_if_timer_exist:T { \sys_timer_gzero: }
%    \end{macrocode}
%
% \subsection{Benchmarking code}
%
%    \begin{macrocode}
%<@@=benchmark>
%    \end{macrocode}
%
% \begin{variable}{\l_benchmark_duration_int}
%   The benchmark is constrained to take roughly
%   (from half to twice) \cs{l_benchmark_duration_int} scaled
%   seconds, unless one iteration of the code takes longer.
%    \begin{macrocode}
\int_new:N \l_benchmark_duration_int
\int_set:Nn \l_benchmark_duration_int { 65536 }
%    \end{macrocode}
% \end{variable}
%
%    \begin{macrocode}
\sys_if_timer_exist:F
  {
    \msg_new:nnnn { benchmark } { no-time }
      { The~l3benchmark~package~failed~to~access~a~clock. }
      {
        The~current~engine~provides~no~way~to~access~the~system~time,~
        hence~making~benchmarking~impossible~without~shell-escape.~
        Please~use~pdfTeX,~LuaTeX,~or~call~other~engines~with~the~
        --shell-escape~option.
      }
    \cs_new_protected:Npn \benchmark:n #1
      {
        \msg_error:nn { benchmark } { no-time }
        \benchmark_display:n { 0 }
      }
    \cs_new_protected:Npn \benchmark_display:n #1
      { \iow_term:x { \tl_to_str:n {#1} ~ seconds } }
    \msg_critical:nn { benchmark } { no-time }
  }
%    \end{macrocode}
%
% \begin{variable}{\l_@@_time_a_tl, \l_@@_time_b_tl}
%   These two variables hold the time before and after running a piece
%   of code, as a decimal number in seconds.
%    \begin{macrocode}
\tl_new:N \l_@@_time_a_tl
\tl_new:N \l_@@_time_b_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_repeat_int}
%   Holds the number of times that the piece of code was
%   repeated when timing.
%    \begin{macrocode}
\int_new:N \l_@@_repeat_int
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_raw:n}
% \begin{macro}[int]{\@@_outer_do_nothing:}
%   The time it took to perform a given piece of code is the difference
%   between the decimal numbers stored in the token lists
%   \cs{l_@@_time_a_tl} and \cs{l_@@_time_b_tl}.  The
%   function \cs{@@_outer_do_nothing:} prevents the arbitrary
%   user code from tampering with the rest of the time module.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_raw:n
  { \sys_timer_apply:N \@@_raw_aux:nn }
\cs_new_protected:Npn \@@_raw_aux:nn #1#2
  {
    #2
    \@@_outer_do_nothing:
    \sys_timer_apply:N \@@_raw_auxii:nn {#1}
  }
\cs_new_protected:Npn \@@_raw_auxii:nn #1#2
  {
    \tl_set:Nn \l_@@_time_a_tl {#2}
    \tl_set:Nn \l_@@_time_b_tl {#1}
  }
\tex_outer:D \cs_set:Npn \@@_outer_do_nothing: { }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_raw_replicate:nn}
%   Here, we wish to measure the time it takes for the piece of code |#2|
%   to be run |#1| times. The \cs{prg_replicate:nn} is expanded before
%   being fed to \cs{@@_raw:n} to avoid timing its expansion as well.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_raw_replicate:nn #1#2
  {
    \exp_args:Nx \@@_raw:n
      { \prg_replicate:nn {#1} { \exp_not:n {#2} } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,int]{\@@_replicate_kibi_fold:n}
%   As its name indicates, expanding this function once yields
%   $1024$ copies of its argument. This is used to avoid reaching
%   the limits of \TeX{}'s memory in case the user input is a very
%   simple piece of code.
%    \begin{macrocode}
\cs_new:Npx \@@_replicate_kibi_fold:n #1
  { \prg_replicate:nn {1024} {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\benchmark:n}
%   The main timing function. First time the user code once.
%   If that took less than half a second, repeat the measurement
%   with $4$ copies of the code. Continue quadrupling the number
%   of copies until reaching a time greater than half a second.
%   If the number of copies required is large (here ${}>1024$),
%   it may exhaust \TeX{}'s main memory. In that case, we
%   replicate $1024$ times less the code
%   |\@@_replicate_kibi_fold:n {#1}|.
%   Once a large enough time was measured, divide that by $65536$
%   and by the number of repetitions.
%   The function \cs{benchmark_display:n} can be redefined by the user
%   if the output should be done differently than to the terminal.
%    \begin{macrocode}
\cs_new_protected:Npn \benchmark:n #1
  {
    \int_set:Nn \l_@@_repeat_int { 1 }
    \@@_raw:n {#1}
    \bool_while_do:nn
      {
        \int_compare_p:nNn
          { \l_@@_time_b_tl - \l_@@_time_a_tl }
          < { \l_benchmark_duration_int / 2 }
      }
      {
        \int_set:Nn \l_@@_repeat_int { 4 * \l_@@_repeat_int }
        \int_compare:nNnTF \l_@@_repeat_int > { 1024 }
          {
            \int_compare:nNnTF \l_@@_repeat_int > { 1048576 }
              {
                \@@_raw_replicate:nn
                  { \l_@@_repeat_int / 1048576 }
                  {
                    \@@_replicate_kibi_fold:n
                      { \@@_replicate_kibi_fold:n {#1} }
                  }
              }
              {
                \@@_raw_replicate:nn { \l_@@_repeat_int / 1024 }
                  { \@@_replicate_kibi_fold:n {#1} }
              }
          }
          { \@@_raw_replicate:nn { \l_@@_repeat_int } {#1} }
      }
    \benchmark_display:f
      {
        \fp_to_tl:n
          {
            ( \l_@@_time_b_tl - \l_@@_time_a_tl )
            / \l_@@_repeat_int / 65536
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\benchmark_display:n}
%   Function to display the time that was measured.
%   This can be redefined by the user.
%    \begin{macrocode}
\cs_new_protected:Npn \benchmark_display:n #1
  { \iow_term:x { \tl_to_str:n {#1} ~ seconds } }
\cs_generate_variant:Nn \benchmark_display:n { f }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Benchmark tic toc}
%
% \begin{variable}{\g_@@_tictoc_int, \g_@@_tictoc_seq}
%    \begin{macrocode}
\int_new:N \g_@@_tictoc_int
\seq_new:N \g_@@_tictoc_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\benchmark_tic:, \@@_tic:n}
%    \begin{macrocode}
\cs_new_protected:Npn \benchmark_tic:
  {
    \int_compare:nTF { \g_@@_tictoc_int == 0 }
      {
        \sys_timer_gzero:
        \@@_tic:n { 0 }
      }
      { \sys_timer_apply:N \@@_tic:n }
  }
\cs_new_protected:Npn \@@_tic:n #1
  {
    \seq_put_right:Nn \g_@@_tictoc_seq {#1}
    \int_gincr:N \g_@@_tictoc_int
    \iow_term:x
      {
        \prg_replicate:nn {\g_@@_tictoc_int} {---+} \space
        TIC
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\benchmark_toc:, \@@_toc:n}
%    \begin{macrocode}
\cs_new:Npn \benchmark_toc:
  {
    \int_compare:nT { \g_@@_tictoc_int == 0 }
      { \msg_error:nn {benchmark} {toc-first} }
    \seq_pop_right:NN \g_@@_tictoc_seq \l_@@_tictoc_pop_tl
    \sys_timer_apply:N \@@_toc:n
  }
\cs_new_protected:Npn \@@_toc:n #1
  {
    \tl_set:Nx \l_@@_tictoc_tl
      { \fp_to_decimal:n { round( (#1 - \l_@@_tictoc_pop_tl) / 65536 , 3 )} }
    \iow_term:x
      {
        \prg_replicate:nn {\g_@@_tictoc_int} {---+} \c_space_tl
        TOC: \c_space_tl
        \l_@@_tictoc_tl \c_space_tl s
      }
    \int_gdecr:N \g_@@_tictoc_int
  }
\msg_new:nnn {benchmark} {toc-first}
  {
    \token_to_str:N \benchmark_toc: \space without~
    \token_to_str:N \benchmark_tic: \space !
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
