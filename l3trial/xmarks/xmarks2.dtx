% \iffalse meta-comment
%
%% File: xmarks.dtx Copyright (C) 2018 Frank Mittelbach, The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
% This file is part of the "l3trial bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/latex3
%
% for those people who are interested.
%
%<*driver|package>
\RequirePackage{xparse}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{xmarks2.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \textsf{xmarks2} package\\Marks^^A
% }
%
% \author{^^A
%  Frank Mittelbach, \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }


% \subsection{Lead-off code}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=marks>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage{xmarks2}{2018-11-20}{}
  {L3 Experimental marks}
%</package>
%    \end{macrocode}
%
%
% \begin{variable}{\g_@@_types_seq}
%   A list of all of the mark types in use.
%    \begin{macrocode}
\seq_new:N \g_@@_types_seq
%    \end{macrocode}
% \end{variable}
%
%
%  \begin{macro}{\g_@@_class_int}
%    We assume that nobody is using extended marks!!!  The alternative
%    is to use \cs{newmarks} from \LaTeXe{} or provide an interface in
%    expl3. One or the other should be dne!
%    \begin{macrocode}
\int_new:N \g_@@_class_int
%    \end{macrocode}
%  \end{macro}
%
%
%    
% \begin{macro}{\marks_new:n}
% \begin{macro}{\@@_new:n}
%    A mark type is created by initialising a number of data
%    structures.  First, we get a number to refer to the mark class.
%    The new mark type is then added to a sequence to be able to
%    easily loop over all types.  finally a number of top-level global
%    token lists are generated that hold various versions of the mark
%    for access.
%    \begin{macrocode}
\cs_new_protected:Npn \marks_new:n #1
{
  \seq_if_in:NnTF \g_@@_types_seq {#1}
      {
        \__kernel_msg_error:nnn { marks } { type-already-defined }
          {#1}
      }
      { \@@_new:n {#1} }
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_new_protected:Npn \@@_new:n #1
{
%<*trace>
  \trace_marks:n { new~mark:~ #1 }
%</trace>
  \int_gincr:N \g_@@_class_int
  \int_const:cn {c_@@_class_ #1 _int}{ \g_@@_class_int }
  \seq_gput_right:Nn \g_@@_types_seq {#1}
  \tl_new:c   { g_@@_page_top_ #1 _tl }
  \tl_new:c   { g_@@_page_first_ #1 _tl }
  \tl_new:c   { g_@@_page_last_ #1 _tl }
  \tl_new:c   { g_@@_verso_top_ #1 _tl }
  \tl_new:c   { g_@@_verso_first_ #1 _tl }
  \tl_new:c   { g_@@_verso_last_ #1 _tl }
  \tl_new:c   { g_@@_recto_top_ #1 _tl }
  \tl_new:c   { g_@@_recto_first_ #1 _tl }
  \tl_new:c   { g_@@_recto_last_ #1 _tl }
  \tl_new:c   { g_@@_col_top_ #1 _tl }
  \tl_new:c   { g_@@_col_first_ #1 _tl }
  \tl_new:c   { g_@@_col_last_ #1 _tl }
  \tl_new:c   { g_@@_1col_top_ #1 _tl }
  \tl_new:c   { g_@@_1col_first_ #1 _tl }
  \tl_new:c   { g_@@_1col_last_ #1 _tl }
  \tl_new:c   { g_@@_2col_top_ #1 _tl }
  \tl_new:c   { g_@@_2col_first_ #1 _tl }
  \tl_new:c   { g_@@_2col_last_ #1 _tl }
}    
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%    
%    \begin{macrocode}
\cs_new:Npn \@@_update_singlecol_structure:
   {
    \if@twoside
      \ifodd \c@page
        \marks_update_structure:nnnN {recto}{page}{page}\@outputbox
      \else
        \marks_update_structure:nnnN {verso}{page}{page}\@outputbox
      \fi
    \else
      \marks_update_structure:nnnN {recto}{page}{page}\@outputbox
      \marks_update_structure_alias:nn {verso}{page}  
    \fi
    \marks_update_structure_alias:nn {col}{page}  
    \marks_update_structure_alias:nn {1col}{page}  
    \marks_update_structure_alias:nn {2col}{page}
%<*trace>
    \marks_status:n {OR:~(\if@twoside twoside- \ifodd \c@page odd\else
      even\fi\else oneside\fi)}
%</trace>
   }
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_new:Npn \@@_update_dblcol_structure:
   {
    \if@firstcolumn
      \marks_update_structure:nnnN {1col}{col}{col}\@outputbox
    \else
      \marks_update_structure:nnnN {2col}{col}{col}\@outputbox
      \if@twoside
        \ifodd \c@page
          \marks_update_complex_structure:nnnn {recto}{page}{page}
            { \unvcopy\@leftcolumn\unskip
              \unvcopy\@outputbox\unskip }
        \else
          \marks_update_complex_structure:nnnn {verso}{page}{page}
            { \unvcopy\@leftcolumn\unskip
              \unvcopy\@outputbox\unskip }
        \fi
      \else
        \marks_update_complex_structure:nnnn {recto}{page}{page}
            { \unvcopy\@leftcolumn\unskip
              \unvcopy\@outputbox\unskip }
      \fi
    \fi
%<*trace>
    \marks_status:n {OR:~(
      \if@twoside twoside- \ifodd \c@page odd\else
      even\fi\else oneside\fi
      \space
      \if@firstcolumn first~ \else second~ \fi
       column)}
%</trace>
   }
  
%    \end{macrocode}
%
%
%    
%    \begin{macrocode}

  \box_new:N \@@_box

  \tl_new:N \g_@@_tmp_tl
  \tl_new:N \g_@@_new_top_tl
  
\cs_new:Npn \marks_update_structure:nnnN #1#2#3#4
   { \marks_update_complex_structure:nnnn
     {#1}{#2}{#3}{ \unvcopy #4 \unskip }
   }
  
%    \end{macrocode}
%    

%  \begin{macro}{\marks_update_complex_structure:nnnn}
%    
%    \begin{macrocode}
\cs_new:Npn \marks_update_complex_structure:nnnn #1#2#3#4
{
  \group_begin:
    \dim_set:Nn \tex_splitmaxdepth:D \c_max_dim
    \int_set:Nn \tex_vbadness:D      \c_max_int
%    \end{macrocode}
%    
%    \begin{macrocode}
    \vbox_set:Nn \@@_box {#4}
    \vbox_set_split_to_ht:NNn \@@_box \@@_box \c_max_dim
%    \end{macrocode}
%    
%    \begin{macrocode}
    \seq_map_inline:Nn \g_@@_types_seq
      {
        \tl_gset_eq:Nc \g_@@_new_top_tl { g_@@_ #3 _last_  ##1 _tl }
%      
        \tl_gset_eq:cN { g_@@_ #2 _top_ ##1 _tl } \g_@@_new_top_tl
        \tl_gset_eq:cN { g_@@_ #1 _top_ ##1 _tl } \g_@@_new_top_tl
%
        \tl_gset:No \g_@@_tmp_tl { \tex_splitbotmarks:D \use:c{c_@@_class_ ##1 _int} }
%    \end{macrocode}
%    If bot mark is empty then obviously first mark too, so both
%    becomes bot mark from last structure
%    \begin{macrocode}
        \tl_if_empty:NTF \g_@@_tmp_tl 
           {
             \tl_gset_eq:cN { g_@@_ #2 _last_  ##1 _tl } \g_@@_new_top_tl
             \tl_gset_eq:cN { g_@@_ #2 _first_ ##1 _tl } \g_@@_new_top_tl
             \tl_gset_eq:cN { g_@@_ #1 _last_  ##1 _tl } \g_@@_new_top_tl
             \tl_gset_eq:cN { g_@@_ #1 _first_ ##1 _tl } \g_@@_new_top_tl
           }
           {
             \tl_gset_eq:cN { g_@@_ #2 _last_ ##1 _tl } \g_@@_tmp_tl
             \tl_gset_eq:cN { g_@@_ #1 _last_ ##1 _tl } \g_@@_tmp_tl
%
             \tl_gset:No    \g_@@_tmp_tl { \splitfirstmarks \use:c{c_@@_class_ ##1 _int} }
             \tl_if_empty:NTF \g_@@_tmp_tl 
                {
                  \tl_gset_eq:cN { g_@@_ #2 _first_ ##1 _tl } \g_@@_new_top_tl
                  \tl_gset_eq:cN { g_@@_ #1 _first_ ##1 _tl } \g_@@_new_top_tl
                }
                {
                  \tl_gset_eq:cN { g_@@_ #2 _first_ ##1 _tl } \g_@@_tmp_tl
                  \tl_gset_eq:cN { g_@@_ #1 _first_ ##1 _tl } \g_@@_tmp_tl
                }
           }
      }
  \group_end:
}
%    \end{macrocode}
%  \end{macro}
%
%

%  \begin{macro}{\marks_update_structure_alias:nn}
%    
%    \begin{macrocode}
\cs_new:Npn \marks_update_structure_alias:nn #1#2
{
  \seq_map_inline:Nn \g_@@_types_seq
      {
        \tl_gset_eq:cc { g_@@_ #1 _top_   ##1 _tl }{ g_@@_ #2 _top_   ##1 _tl }
        \tl_gset_eq:cc { g_@@_ #1 _first_ ##1 _tl }{ g_@@_ #2 _first_ ##1 _tl }
        \tl_gset_eq:cc { g_@@_ #1 _last_  ##1 _tl }{ g_@@_ #2 _last_  ##1 _tl }
      }
}
%    \end{macrocode}
%  \end{macro}
%
%    
%  \begin{macro}{\marks_put:nn}
%    
%    \begin{macrocode}
\cs_new_protected:Npn \marks_put:nn #1#2
{
  \seq_if_in:NnTF \g_@@_types_seq {#1}
      {
%<*trace>
        \trace_marks:n { set~#1~<-~ '\tl_to_str:n {#2}' }
%</trace>
        \tex_marks:D \use:c{c_@@_class_ #1 _int}{ \exp_not:n{#2} }
      }
      {
        \__kernel_msg_error:nnx { marks } { unknown-type }
          { \tl_to_str:n {#1} }
      }
}
%    \end{macrocode}
%  \end{macro}
%
%
%    
%    \begin{macrocode}
\cs_new:Npn \marks_use_first:nn #1#2
   { \use:c { g_@@_ #1 _first_ #2 _tl } }
\cs_new:Npn \marks_use_last:nn #1#2
  {  \use:c { g_@@_ #1 _last_ #2 _tl }  }
\cs_new:Npn \marks_use_previous:nn #1#2
  {  \use:c { g_@@_ #1 _top_ #2 _tl }  }
%    \end{macrocode}
%
%
%
%    
%    \begin{macrocode}
  \cs_new:Npn \marks_status:n #1
     {
       \seq_map_inline:Nn \g_@@_types_seq { \marks_status:nn {#1} {##1} }
     }
     
  \cs_new:Npn \marks_status:nn #1#2
     {
       \int_compare:nNnT \tracingmarks > 1
       {
         \typeout{#1~ #2:}
         \typeout{\@spaces page~ (current):
           | \tl_use:c { g_@@_page_top_ #2 _tl }
           | \tl_use:c { g_@@_page_first_ #2 _tl }
           | \tl_use:c { g_@@_page_last_ #2 _tl }     |}
         \typeout{\@spaces page~ (verso):
           | \tl_use:c { g_@@_verso_top_ #2 _tl }
           | \tl_use:c { g_@@_verso_first_ #2 _tl }
           | \tl_use:c { g_@@_verso_last_ #2 _tl }     |}
         \typeout{\@spaces page~ (recto):
           | \tl_use:c { g_@@_recto_top_ #2 _tl }
           | \tl_use:c { g_@@_recto_first_ #2 _tl }
           | \tl_use:c { g_@@_recto_last_ #2 _tl }     |}
%
         \typeout{\@spaces column~ (current):
           | \tl_use:c { g_@@_col_top_ #2 _tl }
           | \tl_use:c { g_@@_col_first_ #2 _tl }
           | \tl_use:c { g_@@_col_last_ #2 _tl }     |}
         \typeout{\@spaces column~ (first):
           | \tl_use:c { g_@@_1col_top_ #2 _tl }
           | \tl_use:c { g_@@_1col_first_ #2 _tl }
           | \tl_use:c { g_@@_1col_last_ #2 _tl }     |}
         \typeout{\@spaces column~ (second):
           | \tl_use:c { g_@@_2col_top_ #2 _tl }
           | \tl_use:c { g_@@_2col_first_ #2 _tl }
           | \tl_use:c { g_@@_2col_last_ #2 _tl }     |}
       }
}       
%    \end{macrocode}
%
%
%
%    
%    \begin{macrocode}
%    \end{macrocode}
%
%
%
%    
%    \begin{macrocode}
%    \end{macrocode}
%
%
%
%    
%    \begin{macrocode}
%    \end{macrocode}
%
%
% \subsection{Trace support}
%
% \begin{variable}{\tracingmarks}
%   Used to control the amount of trace material placed in the log.
%    \begin{macrocode}
\int_new:N \tracingmarks
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\trace_marks:n, \trace_marks_internal:n}
%   Two trace functions, one more verbose than the other.
%    \begin{macrocode}
%<*trace>
\cs_new_protected:Npn \trace_marks:n #1
  {
    \int_compare:nNnT \tracingmarks > 0
      { \iow_term:x { Marks:~#1~ \msg_line_context: } }
  }
\cs_new_protected:Npn \trace_marks_internal:n #1
  {
    \int_compare:nNnT \tracingmarks > 1
      { \iow_term:x { Marks:~#1 } }
  }
%</trace>
%    \end{macrocode}
% \end{macro}
%
%    
%
% \subsection{Messages}
%
%    \begin{macrocode}
\__kernel_msg_new:nnnn { marks } { type-already-defined }
  { Mark~type~'#1'~already~defined }
  {
    \c__msg_coding_error_text_tl
    LaTeX~was~asked~to~define~a~new~mark~type~called~'#1':~
    this~mark~type~already~exists.
    \c__msg_return_text_tl
  }
\__kernel_msg_new:nnnn { marks } { unknown-type }
  { Unknown~mark~type~'#1'. }
  {
    \c__msg_coding_error_text_tl
    LaTeX~was~asked~to~manipulate~a~mark~of~type~'#1',~but~this~type~of~mark~
    does~not~exist.
  }
%    \end{macrocode}

%    
%
% \subsection{Designer-level interfaces}
%
%    
%    \begin{macrocode}
\cs_new_eq:NN \DeclareMarkType \marks_new:n
\cs_new_eq:NN \PutMark         \marks_put:nn

\NewExpandableDocumentCommand \FirstMark { O{page} m }
                    { \marks_use_first:nn {#1}{#2} }
                      
\NewExpandableDocumentCommand \LastMark { O{page} m }
                    { \marks_use_last:nn {#1}{#2} }
                      
\NewExpandableDocumentCommand \PreviousMark { O{page} m }
{ \marks_use_previous:nn {#1}{#2} }
                      
%    \end{macrocode}
%
%
%
%  \section{\LaTeXe{} integration} 
%    \begin{macrocode}
\RequirePackage{etoolbox}
%    \end{macrocode}
%    
%    \begin{macrocode}
\patchcmd\@opcol
  {\@outputpage}
  {
    \@@_update_singlecol_structure:
    \@outputpage
  }
  {\typeout{\noexpand\@opcol patch~ 1~ successful}}
  {\typeout{\noexpand\@opcol patch~ 1~ failed}}

\patchcmd\@opcol
  {\@outputdblcol}
  {
    \@@_update_dblcol_structure:
    \@outputdblcol
  }
  {\typeout{\noexpand\@opcol patch~ 2~ successful}}
  {\typeout{\noexpand\@opcol patch~ 2~ failed}}
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \section{Supporting marks in floats}
%
% At the moment, marks that are placed into floats do not migrate out
% and thus are never seen. Below are some ideas how the scheme could
% be extended to support use cases that involve marks inside
% floats.
%
% The basic idea is that when the floats are combined to be placed
% into their areas we make a copy of that in an additional box (but
% using \cs{unvcopy} so that the fload body is at top-level in that
% box. Later when getting the marks in the OR via \cs{vsplit} we can
% then  use this content so that any marks inside will be seen too.
%
% \cs{@combinefloats} is not the only place that would need patching
% in that case, the same needs to be done for spanning floats and also
% to the code that adds inline floats. So this is just an outline really.
%    \begin{macrocode}
%<*floats>
%    \end{macrocode}
%    
%    \begin{macrocode}
\box_new:N \@@_floats_box
\box_new:N \@@_tfloats_box
\box_new:N \@@_bfloats_box
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \@combinefloats {%
    \setbox\@@_floats_box\vbox{}%
    \ifx \@toplist\@empty \else
      \@cflt
      \setbox\@@_tfloats_box\vbox{\unvbox\@@_floats_box}
      \setbox\@@_floats_box\vbox{}%
    \fi
    \ifx \@botlist\@empty \else \@cflb \fi
    \setbox\@@_bfloats_box\vbox{\unvbox\@@_floats_box}
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def\@comflelt#1{%
  \setbox\@@_floats_box\vbox{%
    \unvbox\@@_floats_box \unvcopy #1}%  % may need to check that it
                                         %  is a vbox!
      \setbox\@tempboxa
      \vbox{\unvbox\@tempboxa\box #1\vskip\floatsep}}
%    \end{macrocode}
%
%    When getting the marks we then have to look not only at the
%    galley but also at the content of \cs{@@_tfloats_box} etc. In
%    reality that gets even more complex for two columns as we have
%    more float areas then.
%    \begin{macrocode}
\cs_new:Npn \marks_update_structure:nnnN #1#2#3#4
   { \marks_update_complex_structure:nnnn
     {#1}{#2}{#3}
     { \unvcopy\@@_tfloats_box
       \unvcopy #4 \unskip
       \unvcopy\@@_bfloats_box }
   }
%    \end{macrocode}
%    
%    \begin{macrocode}
%</floats>
%    \end{macrocode}
%    
                    
  

  
